<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React.js]]></title>
    <url>%2Fblog%2F2019%2F06%2F06%2Freact%2F</url>
    <content type="text"><![CDATA[敬请期待]]></content>
      <tags>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自用方法汇总]]></title>
    <url>%2Fblog%2F2019%2F06%2F05%2Fcommon%2F</url>
    <content type="text"><![CDATA[移除类123function removeClass(el, cls) &#123; el.className = el.className.replace(new RegExp(&quot;(?:^|\\s)&quot; + cls + &quot;(?:\\s|$)&quot;, &quot;ig&quot;), &quot; &quot;).trim();&#125;; 添加类1234567function addClass(el, cls) &#123; var reg = new RegExp(&quot;(?:^|\\s)&quot; + cls + &quot;(?:\\s|$)&quot;); var ocls = el.className; if (!reg.test(ocls)) &#123; el.className = ocls + &quot; &quot; + cls; &#125;&#125;; 是否含有此类12345678function hasClass(el, cls) &#123; if (el.classList) &#123; return el.classList.contains(cls) &#125; else &#123; var clss = el.className.split(/\s+/) return clss.indexOf(cls) &gt; -1 &#125;&#125; 时间戳转换1234function zhuhuan(day) &#123; re = /(\d&#123;4&#125;)(?:-(\d&#123;1,2&#125;)(?:-(\d&#123;1,2&#125;))?)?(?:\s+(\d&#123;1,2&#125;):(\d&#123;1,2&#125;):(\d&#123;1,2&#125;))?/.exec(day); return new Date(re[1], (re[2] || 1) - 1, re[3] || 1, re[4] || 0, re[5] || 0, re[6] || 0).getTime();&#125;; 获取滚动高度123456789function getScrollTop() &#123; var scrollTop = 0; if (document.documentElement &amp;&amp; document.documentElement.scrollTop) &#123; scrollTop = document.documentElement.scrollTop; &#125; else if (document.body) &#123; scrollTop = document.body.scrollTop; &#125; return scrollTop;&#125;; 数组求和12345function sum(...x) &#123; return x.reduce((m, n) =&gt; m + n);&#125;//or eval(arr.join(&apos;+&apos;)); add 相加123456789101112131415let add = (...a) =&gt; &#123; let helper = (...b) =&gt; &#123; return add(...[...a, ...b]); &#125;; helper.toString = helper.valueOf = () =&gt; &#123; let sum = 0; for (let item of a) sum += item; return sum; &#125;; return helper;&#125;;alert(add(1)(2)) // 3alert(add(1, 2, 3)(10)) // 16alert(add(1)(2)(3)(4)(5)) // 15alert(add(1)(2, 3)(4, 5)) // 15 去重 (可参考上一章 数组去重)12345678Array.from(new Set(arr));//orfunction unique(a) &#123; var res = a.filter(function(item, index, array) &#123; return array.indexOf(item) === index; &#125;); return res;&#125; 字符串倒排1str.split(&quot;&quot;).reverse().join(&quot;&quot;); 快排123456789101112131415161718function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var num = Math.floor(arr.length / 2); var numValue = arr.splice(num, 1); console.log(numValue, &apos;111&apos;) var left = [], right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; numValue) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(numValue, quickSort(right)); //递归不断重复比较&#125; 生成从minNum到maxNum的随机数12345678910111213function randomNum(minNum, maxNum) &#123; switch (arguments.length) &#123; case 1: return parseInt(Math.random() * minNum + 1, 10); break; case 2: return parseInt(Math.random() * (maxNum - minNum + 1) + minNum, 10); break; default: return 0; break; &#125;&#125; 随机排序123456789101112131415161718192021222324252627282930313233343536//推荐使用function shuffle(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; var idx = Math.floor(Math.random() * (len - i)); var temp = arr[idx]; arr[idx] = arr[len - i - 1]; arr[len - i - 1] = temp; &#125; return arr;&#125;//or 完全打乱度不高arr.sort(() =&gt; &#123; return Math.random() &gt;= 0.5 ? 1 : -1;&#125;);//orfunction randArray(data) &#123; //获取数组长度 var arrlen = data.length; //创建数组 存放下标数 var try1 = new Array(); for (var i = 0; i &lt; arrlen; i++) &#123; try1[i] = i; &#125; //创建数组 生成随机下标数 var try2 = new Array(); for (var i = 0; i &lt; arrlen; i++) &#123; try2[i] = try1.splice(Math.floor(Math.random() * try1.length), 1); &#125; //创建数组，生成对应随机下标数的数组 var try3 = new Array(); for (var i = 0; i &lt; arrlen; i++) &#123; try3[i] = data[try2[i]]; &#125; return try3;&#125; 判断属性存在原型还是实例上123function hasPrototypeProperty(obj, name) &#123; return !obj.hasOwnProperty(name) &amp;&amp; (name in obj);&#125; 判断是否是移动端123456789101112function isPc() &#123; var ua = navigator.userAgent; if ((ua.match(/(Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone)/i))) &#123; if (/iPhone|iPad|iPod/.test(ua)) &#123; return &apos;ios&apos; &#125; else if (/Android/.test(ua)) &#123; return &apos;android&apos; &#125; &#125; else &#123; return &apos;PC&apos; &#125;&#125; 检测插件（不支持IE）123456789101112131415161718function hasPlugin(name) &#123; name = name.toLowerCase(); for (let i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125; return false;&#125;//仅支持IEfunction hasIEPlugin(name) &#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex) &#123; return false; &#125;&#125; NodeList转化为数组123456789101112function convertToArray(nodes) &#123; var array = null; try &#123; array = Array.prototype.slice.call(nodes, 0); //针对非IE浏览器 &#125; catch (ex) &#123; array = new Array(); for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; array.push(nodes[i]); &#125; &#125; return array;&#125; 事件监听程序及移除1234567891011121314151617181920var EventUtil = &#123; addHandler: function(ele, type, handler) &#123; if (ele.addEventListener) &#123; ele.addEventListener(type, handler, false); &#125; else if (ele.attachEvent) &#123; ele.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; ele[&quot;on&quot; + type] = handler; &#125; &#125;, removeHandler: function(ele, type, handler) &#123; if (ele.removeEventListener) &#123; ele.removeEventListener(type, handler, false); &#125; else if (ele.detachEvent) &#123; ele.detachEvent(&quot;on&quot; + type, handler); &#125; else &#123; ele[&quot;on&quot; + type] = null; &#125; &#125;&#125;; 获取总的字节数1234567891011function strNum(val) &#123; var len = 0; for (var i = 0, ll = val.length; i &lt; ll; i++) &#123; if (val[i].match(/[^\x00-\xff]/ig) != null) &#123; len += 2; &#125; else &#123; len += 1; &#125; &#125; return len;&#125; 字符过滤–过滤特殊字符123456function filterCode(str) &#123; //过滤中英文单双引号以及空格(\s) var reg = /\\+|\~+|\!+|\@+|\#+|¥+|\￥+|\%+|\^+|\&amp;+|\*+|\(+|\)+|\&apos;+|(\&quot;)+|\$+|`+|\“+|\”+|\‘+|\’+|\s+/g; var res = str.replace(reg, &quot;&quot;); return res;&#125; 由经纬度获取两点间的距离km12345678910111213141516171819202122232425262728293031function calculate(start, end) &#123; //start 起点经纬度,数据格式 start = &#123;lon:,lat:&#125; //end 终点定位度,数据格式 end = &#123;lon:,lat:&#125; if (start.lon != null &amp;&amp; start.lat != null &amp;&amp; end.lon != null &amp;&amp; end.lat != null) &#123; function rad(d) &#123; return d * Math.PI / 180.0; &#125; var slon = start.lon / 3600000; var slat = start.lat / 3600000; var elon = end.lon / 3600000; var elat = end.lat / 3600000; //赤道半径 var EARTH_RADIUS = 6378137; var radLat1 = rad(slat); var radLat2 = rad(elat); var a = radLat1 - radLat2; var b = rad(slon) - rad(elon); var s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2))); s = s * EARTH_RADIUS; //返回公里km var kilometer = Math.round(s * 10000) / 10000000; var kl = kilometer + &quot;&quot;; if (kl.length &gt; 4) &#123; //保留两位小数 return kilometer.toFixed(2); &#125; else &#123; return kilometer; &#125; &#125; return &quot;&quot;;&#125;; 屏蔽刷F5、屏蔽鼠标右键1234567891011121314// F5document.onkeydown = function(e) &#123; var ev = window.event || e; var code = ev.keyCode || ev.which; if (code == 116) &#123; ev.keyCode ? ev.keyCode = 0 : ev.which = 0; cancelBubble = true; return false; &#125;&#125;// 右键document.body.oncontextmenu = function() &#123; return false;&#125;; 判断对象是否为数组123456function isArray(arg) &#123; if (typeof arg === &apos;object&apos;) &#123; return Object.prototype.toString.call(arg) === &apos;[object Array]&apos;; &#125; return false;&#125; 验证邮箱1234function checkMail(str) &#123; var reg = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((\.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/; return reg.test(str);&#125; 转换为驼峰命名格式如：toUpper(‘web kit index’)123456function toUpper(str) &#123; var reg = /\s+(\w)/g; return str.replace(reg, function(a, b) &#123; return b.toUpperCase(); &#125;)&#125; 随机色值1(~~(Math.random() * (1 &lt;&lt; 24))).toString(16) 控制节流12345678910111213141516171819202122232425262728function throttle(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(context); &#125;, 5000);&#125;//orvar throttle = function(fn, interval) &#123; var _self = fn, //保存需要被延迟执行的函数引用 timer, //定时器 firstTime = true; //是否是第一次调用 return function() &#123; var args = arguments, _me = this; if (firstTime) &#123; //如果是第一次调用，不需延迟执行 _self.apply(_me, args); return firstTime = false; &#125; if (timer) &#123; //如果定时器还在，说明上一次延迟执行还没有完成 return false; &#125; timer = setTimeout(function() &#123; //延迟一段时间执行 clearTimeout(timer); timer = null; _self.apply(_me, args); &#125;, interval || 500) &#125;&#125; 格式化时间戳1234567891011121314function formatDate(time) &#123; var now = new Date(time); var year = now.getFullYear(); var month = now.getMonth() + 1; var date = now.getDate(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); return year + &quot;-&quot; + month + &quot;-&quot; + date + &quot; &quot; + dateLang(hour) + &quot;:&quot; + dateLang(minute) + &quot;:&quot; + dateLang(second);&#125;function dateLang(s) &#123; return s &lt; 10 ? &apos;0&apos; + s : s;&#125; 获取地址参数123456function getUrlParam(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 一个格式化货币/千位符的js函数12345678910111213function toMoney(num) &#123; //先把字符串里面除了数字跟.以外的字符去掉 let replacenum = num.replace(/[^\d\.]/g, &apos;&apos;) //把得到的字符串转换成带2位小数的浮点数 let fixednum = parseFloat(replacenum).toFixed(2) //把浮点数拆分成整数和小数2部分 let apartnum = String(fixednum).split(&apos;.&apos;) //把整数部分用toLocaleString方法自动格式化成有千位符的字符串 let localnum = parseInt(apartnum[0]).toLocaleString() //最后 把千位符的字符串 加上小数点 和小数部分 得到完整的结果 let result = localnum + &apos;.&apos; + apartnum[1] return result;&#125; String的金额的转换，转成每3个一个逗号的那个123456789101112131415161718192021222324252627282930313233343536function cut1(str) &#123; var n; var str3 = &apos;&apos;; if (str.indexOf(&apos;.&apos;) == -1) &#123; n = str.length % 3; if (n) &#123; str3 = str.slice(0, n) + str.slice(n).replace(/(\d&#123;3&#125;)/g, &apos;,$1&apos;) &#125; else &#123; str3 = str.replace(/(\d&#123;3&#125;)/g, &apos;,$1&apos;).slice(1) &#125; &#125; else &#123; var str2 = str.split(&apos;.&apos;)[0]; n = str2.length % 3; if (n) &#123; str3 = str2.slice(0, n) + str2.slice(n).replace(/(\d&#123;3&#125;)/g, &apos;,$1&apos;) &#125; else &#123; str3 = str2.replace(/(\d&#123;3&#125;)/g, &apos;,$1&apos;).slice(1) &#125; str3 = str3 + &apos;.&apos; + str.split(&apos;.&apos;)[1]; &#125; return str3;&#125;;//orfunction cut2(str) &#123; var len = str.length, str2 = &apos;&apos;, max = Math.floor(len / 3); for (var i = 0; i &lt; max; i++) &#123; var s = str.slice(len - 3, len); str = str.substr(0, len - 3); str2 = (&apos;,&apos; + s) + str2; len = str.length; &#125; str += str2; return str&#125; 耗时检测123456789101112131415161718var testFun = function(callback, str) &#123; var tipElem = document.createElement(&apos;div&apos;), startTime, duration = 0; for (var j = 5; j &gt; 0; j--) &#123; startTime = +new Date(); for (var i = 10000; i &gt; 0; i--) &#123; callback(); &#125; duration = ((+new Date()) - startTime) + duration; &#125; duration = (duration / 5).toFixed(0); tipElem.innerHTML = str + &apos;总耗时：&apos; + duration + &apos; ms&apos;; document.body.appendChild(tipElem);&#125;;testFun(function() &#123; func(&apos;1123456789&apos;);&#125;, &apos;方法1&apos;); 多维数组转化为一维12345678910111213141516171819202122232425262728// 递归方法function flat(array) &#123; var result = []; let each = function(arr) &#123; arr.forEach(item=&gt; &#123; if(item instanceof Array) &#123; each(item); &#125; else &#123; result.push(item) &#125; &#125;) &#125; each(array); return eval(result.join(&apos;,&apos;));&#125;// 原型方法改造（不影响数组原本方法使用）var flat = function(arr) &#123; let toString = Array.prototype.toString; Array.prototype.toString = function() &#123; return this.join(&apos;,&apos;); &#125;; let result = arr + &apos;&apos;; Array.prototype.toString = toString; // 重新赋值原型方法 return result;&#125;var arr = [&apos;a&apos;,[&apos;b&apos;,&apos;c&apos;],2,[&apos;c&apos;,&apos;d&apos;],3,4,&apos;g&apos;];console.log(flat(arr));//a,b,c,2,c,d,3,4,g fetch 封装123456789101112131415161718192021222324252627282930313233343536373839404142var $requst = function (url, options) &#123; var myHeaders = &#123; &apos;Content-Type&apos;: &apos;text/html; charset=utf-8&apos; &#125;; var init = &#123; credentials: &apos;include&apos;, method: (options &amp;&amp; options.method) || &apos;GET&apos;, headers: (options &amp;&amp; options.headers) || myHeaders, cache: (options &amp;&amp; options.cache) || &apos;default&apos; &#125; if (options &amp;&amp; options.body) &#123; init.body = JSON.stringify(options.body) &#125; return fetch(url, init) .then(function (response) &#123; if (response.ok) &#123; return _returnContentByType(response); &#125; else &#123; if (options &amp;&amp; options.catchs) &#123; throw new Error(response.statusText); &#125; else &#123; var error = new Error(response.statusText); throw new Error(&apos;&apos;); &#125; &#125; &#125;);&#125;;/*** 根据type返回不同格式的response*/var _returnContentByType = function (response) &#123; var type = response.headers.get(&apos;Content-Type&apos;).split(&quot;;&quot;)[0]; switch (type) &#123; case &apos;text/html&apos;: return response.text(); break case &apos;application/json&apos;: return response.json(); break default: &#125;&#125;; 数组中存在最多的元素及个数1234567891011function search(arr) &#123; var maxCount = 0, maxItem = &apos;&apos;, obj = &#123;&#125; arr.forEach(function (item) &#123; obj[item] ? (obj[item].count += 1) : obj[item] = &#123; count: 1 &#125; obj[item].count &gt; maxCount &amp;&amp; (maxCount = obj[item].count, maxItem = item) &#125;) return &#123;item:maxItem,count:maxCount&#125; // return maxItem &#125; 返回一个键盘(很牛b，目前没看懂，感觉是看不懂了)12(_=&gt;[...&quot;`1234567890-=~~QWERTYUIOP[]\\~ASDFGHJKL;&apos;~~ZXCVBNM,./~&quot;].map(x=&gt;(o+=`/$&#123;b=&apos;_&apos;.repeat(w=x&lt;y?2:&apos; 667699&apos;[x=[&quot;BS&quot;,&quot;TAB&quot;,&quot;CAPS&quot;,&quot;ENTER&quot;][p++]||&apos;SHIFT&apos;,p])&#125;\\|`,m+=y+(x+&apos; &apos;).slice(0,w)+y+y,n+=y+b+y+y,l+=&apos; __&apos;+b)[73]&amp;&amp;(k.push(l,m,n,o),l=&apos;&apos;,m=n=o=y),m=n=o=y=&apos;|&apos;,p=l=k=[])&amp;&amp;k.join``)() 说明： 先说声抱歉，有部分方法是摘录的，具体忘记了出处[😅]，很早收集的，现在玩博客了想着搞点干的，如有博主自己看到相同的，可下面评论出处[🙏]，以便修正，禁止转的可下]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2Fblog%2F2019%2F05%2F30%2Farray%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重数组去重是我们工作和学习中经常遇到的问题，我在这里总结几个常用的写法最基本排序(indexOf)12345678910111213/** 根据数组indexOf方法判断数据是否存在（不存在为-1）* indexOf IE8 以下不支持* */function unique(arr)&#123; var n=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(n.indexOf(arr[i])==-1)&#123; n.push(arr[i]); &#125; &#125; return n;&#125; 先排序 再相邻比较123456789101112131415/** 给传入数组排序，排序后相同值相邻，* 然后遍历时,新数组只加入不与前一值重复的值。* 会打乱原来数组的顺序* */function unique1(arr) &#123; arr.sort(); var n = [arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== n[n.length - 1]) &#123; n.push(arr[i]); &#125; &#125; return n;&#125; 双层循环123456789101112function unique2(arr)&#123; var n=[]; for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = i+1; j &lt; arr.length; j++) &#123; if(arr[i]===arr[j])&#123; ++i; &#125; &#125; n.push(arr[i]); &#125; return n;&#125; 使用fliter去重123456function unique(arr) &#123; return arr.filter(function(item, index, arr) &#123; //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; &#125;);&#125; es6123function unique(arr) &#123; return Array.from(new Set(arr))&#125;]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读javaScript数据结构与算法随笔]]></title>
    <url>%2Fblog%2F2019%2F05%2F22%2F%E9%98%85%E8%AF%BBjavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[随笔使用类进行面向对象开发 1234567891011class Book &#123; constructor (title, pages, isbn) &#123; this.title = title; this.pages = pages; this.isbn = isbn; &#125; printIsbn()&#123; console.log(this.isbn); &#125;&#125;只需要使用class关键字，声明一个有constructor函数和诸如printIsbn等其他函数的类 继承12345678910class ITBook extends Book &#123; constructor (title, pages, isbn, technology) &#123; super(title, pages, isbn); this.technology = technology; &#125; printTechnology()&#123; console.log(this.technology); &#125; &#125;我们可以用extends关键字扩展一个类并继承它的行为。在构造函数中，我们可以通过super关键字引用父类的构造函数 栈 后进先出12345678910111213141516171819202122232425262728293031let Stack = (function () &#123; const items = new WeakMap(); class Stack &#123; constructor () &#123; items.set(this, []); &#125; &#125; push(element) &#123; let s = items.get(this); s.push(element); &#125; pop() &#123; let s = items.get(this); let r = s.pop(); return r; &#125; isEmpty() &#123; let s = items.get(this); return s.length == 0 &#125; size() &#123; let s = items.get(this); return s.length &#125; clear() &#123; let s = items.get(this); s.length = 0; // s = [] &#125; return Stack;&#125;)(); 队 先进先出12345678910111213141516171819202122232425262728293031323334let Queue2 = (function () &#123; const items = new WeakMap(); class Queue2 &#123; constructor () &#123; items.set(this, []); &#125; enqueue(element) &#123; let q = items.get(this); q.push(element); &#125; dequeue() &#123; let q = items.get(this); let r = q.shift(); return r; &#125; front() &#123; let q = items.get(this); return q[0] &#125; isEmpty() &#123; let q = items.get(this); return q.length == 0 &#125; size() &#123; let q = items.get(this); return q.length &#125; print() &#123; let q = items.get(this); console.log(q.toString()) &#125; &#125; return Queue2;&#125;)(); 集合12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Agg &#123; constructor() &#123; this.items = &#123;&#125; &#125; has(value) &#123; return this.items.hasOwnProperty(value) &#125; add(balue) &#123; if(!this.has(value)) &#123; // 对于给定的value，可以检查它是否存在于集合中 this.items[value] = value return true // 如果不存在，就把value添加到集合中，返回true，表示添加了这个值 &#125; return false // 如果集合中已经有这个值，就返回false，表示没有添加它 &#125; remove(value) &#123; if(this.has(value)) &#123; // 对于给定的value，可以检查它是否存在于集合中 delete this.items[value] return true // 如果存在，就从集合中移除value，返回true，表示值被移除 &#125; return false // 反之 &#125; clear() &#123; this.items = &#123;&#125; &#125; size6() &#123; return Object.keys(this.items).length // es6 &#125; size5() &#123; let count = 0; // es5 for(let key in this.items) &#123; if(this.items.hasOwnProperty(key)) ++count &#125; return count &#125; values6() &#123; // es6 let values = []; for (let i=0, keys=Object.keys(this.items); i&lt;keys.length; i++) &#123; values.push(this.items[keys[i]]); &#125; return values; &#125; values5() &#123; // es5 let values = []; for(let key in this.items) &#123; if(this.items.hasOwnProperty(key)) &#123; values.push(this.items[key]); &#125; &#125; return values; &#125;&#125; 集合操作并集123456789101112131415161718let union = function(otherSet)&#123; let unionSet = new Agg(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for (let i=0; i&lt;values.length; i++)&#123; unionSet.add(values[i]); &#125; return unionSet;&#125;;let setA = new Set([1,2,3]) // es6 let setB = new Set([2,3,4])let unionES6= new Set(); for (let x of setA) unionES6.add(x); for (let x of setB) unionES6.add(x); 交集12345678910111213141516171819202122let intersection = function(otherSet)&#123; let intersectionSet = new Agg(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (otherSet.has(values[i])) &#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet;&#125;let setA = new Set([1,2,3]) // es6 let setB = new Set([2,3,4]) let intersectionES6 = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if (setB.has(x)) &#123; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125; 差集12345678910111213141516171819202122let difference = function(otherSet)&#123; let differenceSet = new Agg(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (!otherSet.has(values[i]))&#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet;&#125;let setA = new Set([1,2,3]) // es6 let setB = new Set([2,3,4]) let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; &#125; &#125; return differenceSet;&#125; 子集123456789101112let subset = function(otherSet)&#123; if (this.size() &gt; otherSet.size())&#123; return false; &#125; else &#123; let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125;]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
</search>
