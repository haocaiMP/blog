<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2Fblog%2F2019%2F05%2F30%2Farray%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[数组去重数组去重是我们工作和学习中经常遇到的问题，我在这里总结几个常用的写法最基本排序(indexOf)12345678910111213/** 根据数组indexOf方法判断数据是否存在（不存在为-1）* indexOf IE8 以下不支持* */function unique(arr)&#123; var n=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(n.indexOf(arr[i])==-1)&#123; n.push(arr[i]); &#125; &#125; return n;&#125; 先排序 再相邻比较123456789101112131415/** 给传入数组排序，排序后相同值相邻，* 然后遍历时,新数组只加入不与前一值重复的值。* 会打乱原来数组的顺序* */function unique1(arr) &#123; arr.sort(); var n = [arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== n[n.length - 1]) &#123; n.push(arr[i]); &#125; &#125; return n;&#125; 双层循环123456789101112function unique2(arr)&#123; var n=[]; for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = i+1; j &lt; arr.length; j++) &#123; if(arr[i]===arr[j])&#123; ++i; &#125; &#125; n.push(arr[i]); &#125; return n;&#125; 使用fliter去重123456function unique(arr) &#123; return arr.filter(function(item, index, arr) &#123; //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; &#125;);&#125; es6123function unique(arr) &#123; return Array.from(new Set(arr))&#125;]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读javaScript数据结构与算法随笔]]></title>
    <url>%2Fblog%2F2019%2F05%2F22%2F%E9%98%85%E8%AF%BBjavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[随笔使用类进行面向对象开发 1234567891011class Book &#123; constructor (title, pages, isbn) &#123; this.title = title; this.pages = pages; this.isbn = isbn; &#125; printIsbn()&#123; console.log(this.isbn); &#125;&#125;只需要使用class关键字，声明一个有constructor函数和诸如printIsbn等其他函数的类 继承12345678910class ITBook extends Book &#123; constructor (title, pages, isbn, technology) &#123; super(title, pages, isbn); this.technology = technology; &#125; printTechnology()&#123; console.log(this.technology); &#125; &#125;我们可以用extends关键字扩展一个类并继承它的行为。在构造函数中，我们可以通过super关键字引用父类的构造函数 栈 后进先出12345678910111213141516171819202122232425262728293031let Stack = (function () &#123; const items = new WeakMap(); class Stack &#123; constructor () &#123; items.set(this, []); &#125; &#125; push(element) &#123; let s = items.get(this); s.push(element); &#125; pop() &#123; let s = items.get(this); let r = s.pop(); return r; &#125; isEmpty() &#123; let s = items.get(this); return s.length == 0 &#125; size() &#123; let s = items.get(this); return s.length &#125; clear() &#123; let s = items.get(this); s.length = 0; // s = [] &#125; return Stack;&#125;)(); 队 先进先出12345678910111213141516171819202122232425262728293031323334let Queue2 = (function () &#123; const items = new WeakMap(); class Queue2 &#123; constructor () &#123; items.set(this, []); &#125; enqueue(element) &#123; let q = items.get(this); q.push(element); &#125; dequeue() &#123; let q = items.get(this); let r = q.shift(); return r; &#125; front() &#123; let q = items.get(this); return q[0] &#125; isEmpty() &#123; let q = items.get(this); return q.length == 0 &#125; size() &#123; let q = items.get(this); return q.length &#125; print() &#123; let q = items.get(this); console.log(q.toString()) &#125; &#125; return Queue2;&#125;)(); 集合12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Agg &#123; constructor() &#123; this.items = &#123;&#125; &#125; has(value) &#123; return this.items.hasOwnProperty(value) &#125; add(balue) &#123; if(!this.has(value)) &#123; // 对于给定的value，可以检查它是否存在于集合中 this.items[value] = value return true // 如果不存在，就把value添加到集合中，返回true，表示添加了这个值 &#125; return false // 如果集合中已经有这个值，就返回false，表示没有添加它 &#125; remove(value) &#123; if(this.has(value)) &#123; // 对于给定的value，可以检查它是否存在于集合中 delete this.items[value] return true // 如果存在，就从集合中移除value，返回true，表示值被移除 &#125; return false // 反之 &#125; clear() &#123; this.items = &#123;&#125; &#125; size6() &#123; return Object.keys(this.items).length // es6 &#125; size5() &#123; let count = 0; // es5 for(let key in this.items) &#123; if(this.items.hasOwnProperty(key)) ++count &#125; return count &#125; values6() &#123; // es6 let values = []; for (let i=0, keys=Object.keys(this.items); i&lt;keys.length; i++) &#123; values.push(this.items[keys[i]]); &#125; return values; &#125; values5() &#123; // es5 let values = []; for(let key in this.items) &#123; if(this.items.hasOwnProperty(key)) &#123; values.push(this.items[key]); &#125; &#125; return values; &#125;&#125; 集合操作并集123456789101112131415161718let union = function(otherSet)&#123; let unionSet = new Agg(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for (let i=0; i&lt;values.length; i++)&#123; unionSet.add(values[i]); &#125; return unionSet;&#125;;let setA = new Set([1,2,3]) // es6 let setB = new Set([2,3,4])let unionES6= new Set(); for (let x of setA) unionES6.add(x); for (let x of setB) unionES6.add(x); 交集12345678910111213141516171819202122let intersection = function(otherSet)&#123; let intersectionSet = new Agg(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (otherSet.has(values[i])) &#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet;&#125;let setA = new Set([1,2,3]) // es6 let setB = new Set([2,3,4]) let intersectionES6 = function(setA, setB) &#123; let intersectionSet = new Set(); for (let x of setA) &#123; if (setB.has(x)) &#123; intersectionSet.add(x); &#125; &#125; return intersectionSet;&#125; 差集12345678910111213141516171819202122let difference = function(otherSet)&#123; let differenceSet = new Agg(); let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (!otherSet.has(values[i]))&#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet;&#125;let setA = new Set([1,2,3]) // es6 let setB = new Set([2,3,4]) let difference = function(setA, setB) &#123; let differenceSet = new Set(); for (let x of setA) &#123; if (!setB.has(x)) &#123; &#125; &#125; return differenceSet;&#125; 子集123456789101112let subset = function(otherSet)&#123; if (this.size() &gt; otherSet.size())&#123; return false; &#125; else &#123; let values = this.values(); for (let i=0; i&lt;values.length; i++)&#123; if (!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125;]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.js]]></title>
    <url>%2Fblog%2F2019%2F05%2F22%2Freact%2F</url>
    <content type="text"><![CDATA[敬请期待]]></content>
  </entry>
</search>
